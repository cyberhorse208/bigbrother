
## 背景

在一个大型系统中，可能有多个子系统组成。每个子系统都有特定功能，为了实现这些功能，子系统A可能完全自行实现，也有可能需要调用其他子系统的服务才能实现。因此，各个子系统间会存在各种调用关系。


## 目的

监控多个相互调用服务的系统间调用关系、调用频率、调用耗时等。

* 形成调用关系图

* 每个系统都要有统计，包括本系统被调用次数、调用频率、完成调用耗时统计等。

## 限制

* 系统间的tcp连接是短连接，也即一次调用，启动一次tcp连接，调用完成后**客户端主动**关闭连接。


* 不修改使用tcp连接来提供服务的系统业务模块



## 场景

### 场景1

* T1	  系统A收到客户端请求，需要完成功能F1。
*	系统A分析发现功能F1在本系统内部就能够完成，就直接完成F1，通知客户端
* T2	  客户端断开连接


监控预期结果：
>	系统A调用次数+1

>	系统A本次调用耗时T2-T1

### 场景2

* T1	  系统A收到客户端请求，需要完成功能F2。
*	系统A分析发现功能F2需要调用系统B
*	系统A发起tcp连接到系统B，请求功能FB1
* T2    系统B接受连接，分析发现功能FB1需要调用系统C
*	系统B发起tcp连接到系统C，请求功能FC1
* T3	  系统C接受连接，完成功能FC1，通知系统B
* T4	  系统B关闭与C的连接
*	系统B完成功能FB1，通知系统A
* T5 	  系统A关闭与B的连接
*	系统A完成功能F2，通知客户端
* T6	  客户端断开连接

监控预期结果：
>	系统A调用了系统B，系统B调用了系统C

>	系统A调用次数+1

>	系统A本次调用耗时T6-T1

>	系统B调用次数+1

>	系统B本次调用耗时T5-T2

>	系统C调用次数+1

>	系统C本次调用耗时T4-T3

### 场景3

* T1	  系统A收到客户端请求，需要完成功能F3。
*	系统A分析发现功能F3需要调用系统B和C
*	系统A发起tcp连接到系统B，请求功能FB2
*	系统A发起tcp连接到系统C，请求功能FC2
* T2	  系统B接受连接
* T3	  系统C接受连接，
*	系统C完成功能FC2，通知系统A
*	系统B完成功能FB2，通知系统A
* T4 	  系统A关闭与C的连接
* T5	  系统A关闭与B的连接
*	系统A完成功能F2，通知客户端
* T6	客户端断开连接

监控预期结果：
>	系统A调用了系统B、C

>	系统A调用次数+1

>	系统A本次调用耗时T6-T1

>	系统B调用次数+1

>	系统B本次调用耗时T5-T2

>	系统C调用次数+1

>	系统C本次调用耗时T4-T3

## 分析

* 调用开始、完成的标志

从服务端角度，确定一次调用的开始和完成。

> tcp长连接上，仅仅从协议栈的角度，无法确认某次调用的开始标志，也无法确认完成的标志（因为协议栈只能从数据包的角度确认发送和接受，应用层才知道调用的开始和结束）。这也是上文 **限制** 部分限定调用是tcp短连接的原因

> tcp短连接上，一个连接完成一个调用，这样可以将连接建立时，作为调用开始标志；连接断开时，作为调用结束标志



* 调用完成时间的确认：

> tcp连接可能被客户端主动断开，也可能被服务端主动断开，断开的不同方式会影响服务端调用完成时间的确认

> 对服务端来说，主动断开，tcp连接进入FIN-WAIT-1状态；被动断开，tcp连接进入ClOSE-WAIT状态

> 因此，可以在这两个状态插入计时装置，肯定只有一个被触发，即作为调用完成时间标志。

 
 * 调用成功与否的判断