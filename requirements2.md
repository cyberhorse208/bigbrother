
## 背景

在一个大型系统中，可能有多个子系统组成。每个子系统都有特定功能，为了实现这些功能，子系统可能完全自行实现，也有可能需要调用其他子系统的服务才能实现。因此，各个子系统间会存在各种调用关系。


## 目的

监控多个相互调用服务的系统间调用关系、调用频率、调用耗时等。

* 针对单个调用，绘制调用关系图

* 形成系统整体调用关系图，包括每个子系统被调用次数、调用频率、完成调用耗时统计等。




## 限制

* 系统间的tcp连接是短连接，也即一次调用，启动一次tcp连接，调用完成后**客户端主动**关闭连接。


* 不修改使用tcp连接来提供服务的系统业务模块。

* 暂不考虑一个系统不同的请求后，会根据请求参数不同而产生不同的调用。即：下面的场景1、2、3，不会同时发生在系统A上。


## 场景

### 场景1

* T1	  系统A收到客户端请求，需要完成功能F1。
*	系统A分析发现功能F1在本系统内部就能够完成，就直接完成F1，通知客户端
* T2	  客户端断开连接


监控预期结果：
>	系统A调用次数+1

> 	调用traceid为TR1的调用，调用链为 A

>	系统A本次调用耗时T2-T1

### 场景2

* T1	  系统A收到客户端请求，需要完成功能F2。
*	系统A分析发现功能F2需要调用系统B
*	系统A发起tcp连接到系统B，请求功能FB1
* T2    系统B接受连接，分析发现功能FB1需要调用系统C
*	系统B发起tcp连接到系统C，请求功能FC1
* T3	  系统C接受连接，完成功能FC1，通知系统B
* T4	  系统B关闭与C的连接
*	系统B完成功能FB1，通知系统A
* T5 	  系统A关闭与B的连接
*	系统A完成功能F2，通知客户端
* T6	  客户端断开连接

监控预期结果：
>	系统A调用了系统B，系统B调用了系统C

> 	调用traceid为TR2的调用，调用链为 A->B->C

>	系统A调用次数+1

>	系统A本次调用耗时T6-T1

>	系统B调用次数+1

>	系统B本次调用耗时T5-T2

>	系统C调用次数+1

>	系统C本次调用耗时T4-T3

### 场景3

* T1	  系统A收到客户端请求，需要完成功能F3。
*	系统A分析发现功能F3需要调用系统B和C
*	系统A发起tcp连接到系统B，请求功能FB2
*	系统A发起tcp连接到系统C，请求功能FC2
* T2	  系统B接受连接
* T3	  系统C接受连接，
*	系统C完成功能FC2，通知系统A
*	系统B完成功能FB2，通知系统A
* T4 	  系统A关闭与C的连接
* T5	  系统A关闭与B的连接
*	系统A完成功能F2，通知客户端
* T6	客户端断开连接

监控预期结果：
>	系统A调用了系统B、C

> 	调用traceid为TR3的调用，调用链为 A->B, A->C

>	系统A调用次数+1

>	系统A本次调用耗时T6-T1

>	系统B调用次数+1

>	系统B本次调用耗时T5-T2

>	系统C调用次数+1

>	系统C本次调用耗时T4-T3

## 分析

### 调用开始、完成的标志

从服务端角度，确定一次调用的开始和完成。

> tcp长连接上，可能有多个调用，仅仅从协议栈的角度，无法确认某次调用的开始标志，也无法确认完成的标志（因为协议栈只能从数据包的角度确认发送和接受，应用层才知道调用的开始和结束）。这也是上文 **限制** 部分限定调用是tcp短连接的原因

> tcp短连接上，一个连接完成一个调用，这样可以将连接建立时，作为调用开始标志；连接断开时，作为调用结束标志。

1. 调用开始时间的确认

> 服务端连接进入ESTABLISHED状态的时间，作为调用开始的时间。此开始时间排除了3次握手的时间，包含了服务器由于繁忙来不及接收请求导致的请求等待时间。

2. 调用完成时间的确认

> tcp连接可能被客户端主动断开，也可能被服务端主动断开，断开的不同方式会影响服务端调用完成时间的确认

> 对服务端来说，主动断开，tcp连接进入FIN-WAIT-1状态；被动断开，tcp连接进入ClOSE-WAIT状态

> 因此，可以在这两个状态插入计时装置，肯定只有一个被触发，即作为调用完成时间标志。
 
 
### 单个调用跟踪
 
单个调用的跟踪关键在于识别调用之间的相关性，即某个入站请求需要正确关联到某个出站请求。识别相关性有两种方式：
 
 1. 在每个请求中添加traceid字段，凡是traceid相同的请求都属于同一个原始请求的调用链。
 
2. 不依赖traceid字段，单独从连接的其他属性来作匹配，从而形成调用链；最后给识别出的调用链一个标示traceid。

* 请求中包含traceid的情况

> 不对app进行任何改动的前提下，traceid可以放在tcp的header或者是data部分

> traceid放在header里面，需要修改内核协议栈；无论是否出错，不影响业务功能

> traceid放在data里面，需要hook glic的send，recv函数，分别进行添加traceid和剥离traceid的操作；一旦添加或者剥离失败，会影响业务功能。


> 必须正确传递traceid，就是要从协议栈角度，识别服务接受的入站请求和发出的出站请求的相关性。

* 请求中不包含traceid情况
 
> 通过连接的属性来匹配，比如服务A的出站请求与它请求的服务B的入站请求就可以通过ip+port来匹配。
 
> 连接的ip、port属性可以从/proc/net/tcp获得，无须修改任何协议栈或者glibc代码。
 
 > 必须正确判断服务接受的入站请求和发出的出站请求的相关性。
 
 两种方式都必须要正确判断请求的派生关系，即：服务接受的入站请求和发出的出站请求的相关性，但很显然不包含traceid的方式要更简单，更容易实现。
 
下面我们仅讨论请求中不包含traceid的情况。


仅仅从协议栈的角度，要正确的判断派生关系，非常困难。我们可以简单的梳理下从接受入站请求、发出出站请求、完成请求的过程，来判断困难点。

> 假设B系统在端口8000上提供服务，C系统在9000上提供服务。

> A通过端口23919向B的8000端口发出握手请求SYN，B向A发出SYN、ACK，B将其放入等待队列。B的/proc/net/tcp 中出现一个条目B:8000 A:23919，状态为TCP_SYN_RECV。

> A返回ACK。B的/proc/net/tcp 中条目B:8000 A:23919状态变为TCP_ESTABLISHED。

> 应用程序app调用accept函数，从backlog等待队列中取出队头待接受请求，进行处理。

> app处理过程中，发现需要调用上游服务器C的服务，就调用connect函数，发出调用请求（通过随机端口23422）。B的/proc/net/tcp 中出现一个条目 B:23422 C:9000，状态为TCP_SYN_SENT。

> C接受请求，完成3次握手。B的/proc/net/tcp 中条目 B:23422 C:9000，状态变为TCP_ESTABLISHED。

> B、C交换数据。C告诉B，处理结束。

> app主动关闭上游连接。B的/proc/net/tcp 中条目 B:23422 C:9000状态变为TCP_FIN_WAIT1。

> app后续处理，完毕后，告诉A请求处理结束。

> A关闭上游连接。B的/proc/net/tcp 中条目B:8000 A:23919状态变为TCP_CLOSE_WAIT。


那么现在的问题就是，如何判断条目B:23422 C:9000是从条目B:8000 A:23919派生的？

需要认识到的是：

1. 下游A服务器可能同时发起多个请求，导致B系统同时出现多个TCP_ESTABLISHED的条目；

2. app可能在任何时候、任何顺序调用accept，从而导致TCP_ESTABLISHED的条目可能以任何顺序被app处理；

3. app可能以任何时候调用上游服务器，即状态为TCP_SYN_SENT的派生条目出现的顺序不一定就是状态为TCP_ESTABLISHED的原始请求条目出现的顺序；

4. 如果一个设备上有多个app运行，必须要有方法能够区分连接到底属于那个app；

基于以上认识，我们必须作如下假设才能对入站请求和出站请求作正确匹配 ：

**app调用accept后，进行内部处理，然后调用connect，再进行内部处理，完成后才能再次调用accept，也就是app是串行处理网络请求的。**

对应的匹配规则是：

**状态最先变为TCP_ESTABLISHED的原始请求，对应着最近出站的TCP_SYN_SENT状态请求，也就是“先入先出”。**
 
 
### 系统调用关系图
 
 > 每个tcp连接都有本端地址和对端地址，可以通过记录每个连接的两端地址来获得调用关系
 
## 实现
 
 基于 [/proc/net/tcp](https://github.com/cyberhorse208/bigbrother/blob/master/proc_net_tcp.md)文件内容来实现。**默认假设，需要确认：/proc/net/tcp中连接的出现时间、状态变化与协议栈中存在的连接有着严格的对应关系。**
 
### 识别连接属于目标应用。

可选方法是：

> 根据app名字，获得进程号码pid，运行命令
```bash
ll /proc/pid/fd |grep socket 
```
> 获得所有打开的socket，例如：
```bash
lrwx------ 1 will will 64 6月  21 16:23 8 -> socket:[54439]
lrwx------ 1 will will 64 6月  21 16:45 87 -> socket:[64756]
lrwx------ 1 will will 64 6月  21 16:45 89 -> socket:[64757]
```
> socket:[xxx]的xxx就是在/proc/net/tcp中inode列中出现的值，对应的连接都属于这个app。

### 服务器工作过程：

1. 从中央服务器拉取本机上所有app，及其服务信息。

2. 实时刷新app的打开的socket列表。

3. 实时刷新/proc/net/tcp，针对每个app的socket列表，作如下操作：

> 根据app的服务端口，判断出站socket和入站socket，并根据进入TCP_ESTABLISHED状态的时间S（调用开始时间）先后顺序，形成入站队列。

> 根据分析中的假设，app同一时间，最多打开一个出站连接，这个连接与入站队列的对头相匹配。记录此匹配信息(包含两个连接的local_address 和 rem_address)。

> 入站队列对头连接状态变为TCP_ClOSE_WAIT时，记录时间E（调用结束时间）。

> 向中央服务器上报本机发生调用信息：（local_address，入站local_address+rem_address, [出站local_address+rem_address]， S，E）
 
### 中央服务器工作过程

* 中央服务器存储每个提供服务的app的信息（name，ip，port），并接收各个服务上报的调用关系。

* 根据各个服务器上报的调用信息，进行匹配，形成调用链，同时可以对调用链的每个层级进行编号。
 
 > 调用链源头， 只有出站连接，traceid可以在这里生成，生成规则自定义。
 
 > 调用链中间节点，有出站连接和入站连接，并且有出入站连接的对应关系。下一个节点的入站连接和上一个节点的出站连接是相同的（local和rem互换），可以用来连接两个节点。
 
 > 调用链末端，只有入站连接。
 
 * 统计每个服务器上的调用信息，可以得到每个系统的调用频率，完成时间等。
 
 